Semantic Analysis
=================

Once a string has been lexed into tokens, the tokens can be structured using a StructureParser. The syntax of programming languages is often recursive. Algebraic expressions have recursive syntax; the contents of parenthesis are treated as another, separate expression. This kind of recursive syntax may be thought of as a tree structure: ::

	f(x+2)

may be represented as the following tree structure: ::

	Node "f" with children:
		Node: "x"
		Node: "+"
		Node: "2"

This is the "structuring" process performed by the StructureParser. It takes a list of tokens as input and results in an abstract syntax tree (AST). A recursive syntax element is called a *bound*. All bounds have a start (i.e. a left parenthesis) and an end (i.e. a right parenthesis) token. Some recursive bounds may have multiple elements. For example, argument lists exist within parenthesis bounds, but have many elements separated by commas.

ASTs
----

The AST type in MPTK has a few different attributes. Each node has a node name, describing what kind of node it is (i.e. expression bound, expression element, etc.). It can be either a leaf, consisting of a single token, or a branch consisting of a list of children nodes.::

	AST leaf1 = AST::createLeaf(Token("1"));
	AST leaf2 = AST::createLeaf(Token("2"));

	AST branch = AST::createBranch("testnode");
	branch.append(leaf1);
	branch.append(Token("+"));
	branch.append(leaf2);

	cout << "branch has " << branch.size() << " children\n";

	for (auto i : branch)
	{
		// i.leaf() gets a reference to the AST leaf's token.
		cout << "\t" << i.leaf().value << "\n";
	}

The result of the above program is::

	branch has 3 children
		1
		+
		2


Structural Parsing
------------------

Let us create a structure parser for C-like expressions. ::

	StructureParser parser = StructureParser("global", ";");
	// 'global' is the given name of the highest-level root node in the AST
	// ';' is the token that splits top-level elements
	// this means that you can list multiple expressions separated by ';'s

	parser.bind("expression", "(", ")", "expressionElement", ",");

This parser may be used to parse an AST tree from a vector of tokens. In order to parse a token vector with this object, however, an error handler is needed. This is an object that inherits from the ErrorHandler class. Although you are encouraged to write your own, MPTK does provide an internal error handler class InternalErrorHandler which can be used for testing and debugging. We can create a new internal error handler with the following code: ::

	InternalErrorHandler eh;
	eh.setFileName("--"); // sets the file name to be displayed with the errors
	eh.setFileBody(fileContents); // set this to the string containing the whole file's contents
	// if you want the line of code that the error originated from to appear alongside the error.

Note that the *ErrorHandler* class was named with the acronym 'eh' in mind. If *toks* contains the following tokens ::

	"f", "(", "x", "+", "2", ")"

Its structure can be parsed with the following code: ::

	AST ast = parser.parse(toks, eh);

*ast* will now contain the structured representation of the above tokens: ::

	cout << ast.display() << "\n";

Which will result in: ::

	(global: 'f' (expression: (expressionElement: 'x' '+' '2')))

Expression Parsing
------------------

Many programming languages will have algebraic expressions with literals, symbols, operators, and function calls. Handling expressions manually is cumbersome, so MPTK provides a parser which re-arranges existing ASTs containing expressions into a more pragmatic form, closely resembling a LISP tree structure. This process is accomplished with the ExpressionParser class. ::

	ExpressionParser ep;

	ep.setExpressionBound("expression"); // this tells the expression parser that this particular AST node should be associated with expressions
	ep.setExpressionElement("expressionElement");
	ep.setFunctionNode("functionCall"); // in the generated AST, this node name is associated with a function call
	ep.setOperationUnaryLeftNode("unaryLeftOperation"); // in the generated AST, this node name is associated with a left unary operation
	ep.setOperationUnaryRightNode("unaryRightOperation"); // this node name is associated with a right unary operation
	ep.setOperationBinaryNode("binaryOperation"); // this for a binary operation

	ep.addBinaryOperator("+"); // this tells the expression parser to expect '+' as a binary operator

This parser, too, requires an expression handler. If we take the *ast* generated by the structure parser in the previous section as input to this parser, we can perform the expression parser operation. ::

	AST expr = ep.parse(ast, eh);
	cout << expr.display() << "\n";

Which will result in: ::

	(global: (functionCall: (binaryOperation: 'x' '+' '2')))